# SQLD [과목1] 2장 2절 정규화와 성능

작성일시: 2023년 8월 21일 오후 4:56
종류: SQL
복습: No

## 🟰정규화를 통한 성능 향상 전략

- [ ]  정규화란?
    
    다양한 유형의 검사를 통해 데이터 모델을 좀더 구조화하고 개선시키는 절차에 관련된 이론
    
    데이터에 대한 중복성을 제거
    
    데이터가 관심사별로 처리되어 성능이 향상
    
- [ ]  데이터베이스에서의 성능 구분
    
    조회 성능
    
    입력/수정/삭제 성능
    
    두 성능이 모두 우수하긴 힘들다 (Trade-Off 되어 나타나는 경우)
    
- [ ]  정규화의 수행
    
    데이터를 결정하는 `**결정자**`에 의해 `**함수적 종속**`을 가지고 있는 일반 속성을 `**의존자**`로 하여 입력/수정/삭제 이상을 제거하는 것
    
    데이터의 중복속성을 제거
    
    결정자에 의해 동일한 의미의 일반속성이 하나의 테이블로 집약되어 한 테이블의 데이터 용량이 최소화 된다
    
    따라서 정규화 된 테이블은 데이터를 처리할 떄 속도가 빨라질 수도 있고 느려질 수도 있다.
    
    ![https://postfiles.pstatic.net/20151204_201/liberty264_14492141906439YEft_JPEG/1.jpg?type=w3](https://postfiles.pstatic.net/20151204_201/liberty264_14492141906439YEft_JPEG/1.jpg?type=w3)
    

## 🟰 반정규화된 테이블의 성능저하 사례

![https://postfiles.pstatic.net/20151204_229/liberty264_1449214256854Q73sD_JPEG/2.jpg?type=w3](https://postfiles.pstatic.net/20151204_229/liberty264_1449214256854Q73sD_JPEG/2.jpg?type=w3)

📌좌측은 정규화가 안 된 부분, 우측은 부분 종속을 정규화하여 두개의 테이블로 분리한 부분

- [ ]  2차 정규화가 안된 테이블
    
    직급명과 함께 반 정규화 된 관서번호, 관서명을 조회하면 하나의 테이블에서 데이터가 조회된다.
    
- [ ]  2차 정규화된 테이블
    
    관서번호, 관서명이 관서테이블에만 존재하기 때문에 두 개의 테이블을 조인하려 처리해야 한다.
    

📌정규화/ 비정규화 테이블의 차이점

- [ ]  사실상 큰 차이가 나지는 않는다.
- [ ]  하지만 불필요하게 납부자 번호 만큼 누적된 데이터를 읽어서 결과를 구분하여 보여주는 것보다 관서수 만큼만 존재하는 데이터를 읽어 곧바로 결과를 보여주는게 성능적으로 더 좋다

![https://postfiles.pstatic.net/20151204_267/liberty264_1449214351300PNPcH_JPEG/3.jpg?type=w3](https://postfiles.pstatic.net/20151204_267/liberty264_1449214351300PNPcH_JPEG/3.jpg?type=w3)

## 🟰반정규화된 테이블의 성능저하 사례2

두 개의 엔터티가 통합되어 반정규화된 또 다른 경우

![https://postfiles.pstatic.net/20151204_28/liberty264_1449214595371gKWrM_JPEG/4.jpg?type=w3](https://postfiles.pstatic.net/20151204_28/liberty264_1449214595371gKWrM_JPEG/4.jpg?type=w3)

📌이 업무는 어떤 물건을 매각할 때 매각일자를 정하고 그 일자에 해당하는 매각시간과 매각장소가 결정하는 속성의 성격을 가지고 있다.

📌매각일자가 결정자가 되고 매각시간과 매각장소가 의존자가 되는 함수적 종속관계가 형성되는 관계이다.

📌대량의 데이터에서 조인 조건이 되는 대상을 찾기 위해 인라인뷰를 사용하기 때문에 성능이 저하된다.

📌복합식별자 중에서 일반 속성이 주식별자 속성 중 일부에만 종속관계를 가지고 있으므로 제2차 정규화 대상이 된다.

✅해결한 테이블

![https://postfiles.pstatic.net/20151204_120/liberty264_14492148571606lx7i_JPEG/5.jpg?type=w3](https://postfiles.pstatic.net/20151204_120/liberty264_14492148571606lx7i_JPEG/5.jpg?type=w3)

📌2차 정규화를 적용하여 매각일자를 PK로 하고 매각시간과 매각장소는 일반 속성이 되었다.

📌정규화를 적용하여서 매각일자를 PK로 사용하는 매각일자별매각내역과도 관계가 연결된다.

📌업무 흐름에 따른 정확한 데이터 모델링 표기도 가능해지고, 드라이빙이 된 테이블이 5천건의 매각기일 테이블이 되므로 성능도 향상된다.

## 🟰 반정규화된 테이블의 성능저하 사례3

📌동일한 속성 형식을 두 개 이상의 속성으로 나열하여 반정규화한 사례

📌모델이라고 하는 테이블에 업무적으로 필요한 8개의 인덱스가 이미 생성되어 있다.

📌유형기능분류에 따라 데이터를 조회해야 하는 경우가 많이 나타나 인덱스를 생성하려면 유형기능분류코드 각각에 대해 인덱스를 생성해야 하므로 9개나 되는 인덱스를 추가 생성해야 한다.

![https://postfiles.pstatic.net/20151204_272/liberty264_1449214900340U2g50_JPEG/6.jpg?type=w3](https://postfiles.pstatic.net/20151204_272/liberty264_1449214900340U2g50_JPEG/6.jpg?type=w3)

📌 한 테이블에 인덱스가 많아지면 조회 성능은 향상되지만 데이터 입력/수정/삭제 성능은 저하된다.

📌일반 업무처리(온라인성 업무)에서는 인덱스 수를 가급적 7~8개가 넘지 않도록 하는게 좋다.

📌각 유형코드별로 조건을 뷰여하여 모델코드와 모델명을 조회하는 SQL문은 아래와 같다.

```sql
SELECT 모델코드,

       모델명

  FROM 모델

 WHERE ( A유형기능분류코드1 = '01' )

    OR ( B유형기능분류코드2 = '02' )

    OR ( C유형기능분류코드3 = '07' )

    OR ( D유형기능분류코드4 = '01' )

    OR ( E유형기능분류코드5 = '02' )

    OR ( F유형기능분류코드6 = '07' )

    OR ( G유형기능분류코드7 = '03' )

    OR ( H유형기능분류코드8 = '09' )

    OR ( I유형기능분류코드9 = '09' );
[출처] 제 2절 정규화와 성능|작성자 지그드시
```

📌각 유형별로 모두 인덱스가 걸려 있어야만 인덱스에 의해 데이터를 찾을 수 있다.

📌이러한 모델은 중복속성에 대한 분리가 필요하므로 1차 정규화 대상이다.

📌1차 정규화로 분리한 후 SQL문

```sql
SELECT A.모델코드, A.모델명

  FROM 모델 A, 모델기능분류코드 B

 WHERE ( B.유형코드 = 'A'

           AND B.기능분류코드 = '01'

           AND A.모델코드 = B.모델코드 )

    OR ( B.유형코드 = 'B'

           AND B.기능분류코드 = '02'

           AND A.모델코드 = B.모델코드 )

    OR ( B.유형코드 = 'C'

           AND B.기능분류코드 = '07'

           AND A.모델코드 = B.모델코드 )

    OR ( B.유형코드 = 'D'

           AND B.기능분류코드 = '01'

           AND A.모델코드 = B.모델코드 )

    OR ( B.유형코드 = 'E'

           AND B.기능분류코드 = '02'

           AND A.모델코드 = B.모델코드 )

    OR ( B.유형코드 = 'F'

           AND B.기능분류코드 = '07'

           AND A.모델코드 = B.모델코드 )

    OR ( B.유형코드 = 'G'

           AND B.기능분류코드 = '03'

           AND A.모델코드 = B.모델코드 )

    OR ( B.유형코드 = 'H'

           AND B.기능분류코드 = '09'

           AND A.모델코드 = B.모델코드 )

    OR ( B.유형코드 = 'I'

           AND B.기능분류코드 = '09'

           AND A.모델코드 = B.모델코드 ) ;
[출처] 제 2절 정규화와 성능|작성자 지그드시
```

📌위 SQL구문은 유형코드 + 기능분류코드 + 모델코드에 인덱스가 걸려 잇으므로 인덱스를 통해 조회함으로써 성능이 향상된다.

## 🟰반정규화된 테이블의 성능저하 사례4

![https://postfiles.pstatic.net/20151204_270/liberty264_1449214991691qJE10_JPEG/7.jpg?type=w3](https://postfiles.pstatic.net/20151204_270/liberty264_1449214991691qJE10_JPEG/7.jpg?type=w3)

📌일재고와 일재고 상세를 구분함으로써 일재고에 발생되는 트랜잭션 성능저하를 예방할 수 있다.